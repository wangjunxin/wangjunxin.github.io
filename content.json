{"meta":{"title":"wangjunxin","subtitle":"","description":"","author":"wangjunxin","url":"http://wangjunxin.github.io","root":"/"},"pages":[{"title":"前端模糊搜索","date":"2020-06-15T09:58:13.000Z","updated":"2020-06-15T13:20:34.003Z","comments":true,"path":"前端模糊搜索/index.html","permalink":"http://wangjunxin.github.io/%E5%89%8D%E7%AB%AF%E6%A8%A1%E7%B3%8A%E6%90%9C%E7%B4%A2/index.html","excerpt":"","text":"前端城市列表模糊搜索Created By: junxin wangLast Edited: Jun 15, 2020 9:16 PMTags: ideas 起因前两天刷知乎看到一个阿里的面试题，说是城市列表的模糊搜索，例如a州能搜索到杭州 现有城市列表 [‘杭州’, ‘上海’, ‘衢州’, ‘三亚’]输入 a州输出结果：杭州 思路 首先输入a州能匹配到杭州，也就是搜索需要支持拼音，其次a并不是杭字的首字母，所以需要对每个字符进行精确到单拼音的字节切分 针对之后需要切分搜索关键字来取得对应的结果，采用对象来存储数据（方便提取） 根据搜索关键字获取的数据后需要进行交集操作，所以以原数组的index作为城市的id，这样方便之后的交集操作 根据搜索关键字获得最后交集后，根据结果的index数组返回城市列表 返回结果还需要与关键字进行顺序匹配，筛除顺序不一致数据（TO DO） 不足目前还没完善搜索关键字顺序造成的搜索结果问题，例如a州与州a的搜索结果一致，在州a的搜索结果中需要剔除例如杭州这类数据。（TO DO） 生成字符表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const pinyin = require(\"pinyin\");let cnMap = &#123;&#125;class fuzzySearch &#123; formateCNMap(list) &#123; sourceLsit = list list.forEach((item, index) =&gt; &#123; for (let i of item) &#123; this.formateMapforCN(i, index) if (this.isCN(i)) &#123; this.dismantleCN(i, index) &#125; &#125; &#125;) console.log(cnMap) &#125; // 检验输入是否为中文 isCN(item) &#123; const cn = /[\\u4e00-\\u9fa5]/ return cn.test(item) &#125; // 将中文转为拼音，然后根据拼音单字节放入表中，push的数据为数组的index dismantleCN(cn, index) &#123; const result = pinyin(cn, &#123;style: pinyin.STYLE_NORMAL&#125;)[0][0] for (let i of result) &#123; if (cnMap[i]) &#123; if (cnMap[i].indexOf(index) &lt; 0) &#123; cnMap[i].push(index) &#125; &#125; else &#123; cnMap[i] = [index] &#125; &#125; &#125; formateMapforCN(item, index) &#123; if (cnMap[item]) &#123; if (cnMap[item].indexOf(index) &lt; 0) &#123; cnMap[item].push(index) &#125; &#125; else &#123; cnMap[item] = [index] &#125; &#125;&#125;const fuzzysearch = new fuzzySearch()const list = ['杭州', '上海', '重庆', '三亚']fuzzysearch.formateCNMap(list) 12345678910111213141516171819202122结果：&#123; '杭': [ 0 ], h: [ 0, 1, 2 ], a: [ 0, 1, 3 ], n: [ 0, 1, 2, 3 ], g: [ 0, 1, 2 ], '州': [ 0 ], z: [ 0, 2 ], o: [ 0, 2 ], u: [ 0 ], '上': [ 1 ], s: [ 1, 3 ], '海': [ 1 ], i: [ 1, 2 ], '重': [ 2 ], '庆': [ 2 ], q: [ 2 ], '三': [ 3 ], '亚': [ 3 ], y: [ 3 ]&#125; 搜索功能1234567891011121314151617181920212223242526272829303132333435363738394041search(keys) &#123; let result = [] let first = true if (!this.checkKey(keys)) &#123; return [] &#125; // 当搜索关键字在字符表中均存在的情况下 // 第一个关键字匹配的字符表数据放入result中 for (const key of keys) &#123; if (cnMap[key] &amp;&amp; first) &#123; result = cnMap[key] first = false &#125; else if (cnMap[key]) &#123; // 之后的关键字匹配的数据与现有result结果取交集 result = result.filter(function(v)&#123; return cnMap[key].indexOf(v) &gt; -1 &#125;) &#125; &#125; // 获得的结果交集是对应的source list的index数组 const data = this.keyToData(result) return data; &#125; // 检查搜索项在字符表中均存在，不存在则没有匹配结果 checkKey(keys) &#123; for (const key of keys) &#123; if (!cnMap.hasOwnProperty(key)) &#123; return false &#125; &#125; return true &#125; // 根据index数组取回城市列表数据 keyToData(list) &#123; let result = [] list.forEach(item =&gt; &#123; result.push(sourceLsit[item]) &#125;) return result; &#125; fuzzysearch.search('a州') // [ '杭州' ] 结果 关键字顺序验证to do"}],"posts":[{"title":"排序算法","slug":"排序算法","date":"2020-05-26T08:46:28.319Z","updated":"2020-06-15T09:34:57.384Z","comments":true,"path":"2020/05/26/排序算法/","link":"","permalink":"http://wangjunxin.github.io/2020/05/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"算法Created By: junxin wangLast Edited: May 18, 2020 5:57 PM 冒泡算法 时间复杂度： O(n^2)比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 12345678910111213function bubbleSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len - 1; i++) &#123; for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; // 相邻元素两两对比 var temp = arr[j+1]; // 元素交换 arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125; 改进冒泡算法，在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) 12345678910111213141516171819202122function bubbleSort3(arr3) &#123; var low = 0; var high = arr.length - 1; //设置变量的初始值 var tmp, j; while (low &lt; high) &#123; for (j = low; j &lt; high; ++j) //正向冒泡,找到最大者 if (arr[j] &gt; arr[j + 1]) &#123; tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; &#125; -- high; //修改high值, 前移一位 for (j = high; j &gt; low; --j) //反向冒泡,找到最小者 if (arr[j] &lt; arr[j - 1]) &#123; tmp = arr[j]; arr[j] = arr[j - 1]; arr[j - 1] = tmp; &#125; ++ low; //修改low值,后移一位 &#125; return arr3;&#125; 选择算法 O(n^2) 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置 从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复第二步，直到所有元素均排序完毕。 12345678910111213141516function selectionSort(arr) &#123; var len = arr.length; var minIndex, temp; for (var i = 0; i &lt; len - 1; i++) &#123; minIndex = i; for (var j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; // 寻找最小的数 minIndex = j; // 将最小数的索引保存 &#125; &#125; temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; return arr;&#125; 插入排序 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后；重复2~5 1234567891011121314151617function insertionSort(array) &#123; if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') &#123; console.time('插入排序耗时：'); for (var i = 1; i &lt; array.length; i++) &#123; var key = array[i]; var j = i - 1; while (j &gt;= 0 &amp;&amp; array[j] &gt; key) &#123; array[j + 1] = array[j]; j--; &#125; array[j + 1] = key; console.log(array) &#125; console.timeEnd('插入排序耗时：'); return array; &#125;&#125; 结合二分法 12345678910111213141516171819202122function binaryInsertionSort(array) &#123; console.time('二分插入排序耗时：'); for (var i = 1; i &lt; array.length; i++) &#123; var key = array[i], left = 0, right = i - 1; while (left &lt;= right) &#123; var middle = parseInt((left + right) / 2); if (key &lt; array[middle]) &#123; right = middle - 1; &#125; else &#123; left = middle + 1; &#125; &#125; for (var j = i - 1; j &gt;= left; j--) &#123; array[j + 1] = array[j]; &#125; array[left] = key; &#125; console.timeEnd('二分插入排序耗时：'); return array;&#125; 希尔排序 O(nlog n)希尔排序是将待排序的数组元素 按下标的一定增量分组 ，分成多个子序列，然后对各个子序列进行直接插入排序算法排序；然后依次缩减增量再进行排序，直到增量为1时，进行最后一次直接插入排序，排序结束。 *增量d 的范围： *1&lt;= d &lt; 待排序数组的长度 （d 需为 int 值）*增量的取值： *一般的初次取序列（数组）的一半为增量，以后每次减半，直到增量为1。第一个增量=数组的长度/2,第二个增量= 第一个增量/2,第三个增量=第二个增量/2,以此类推，最后一个增量=1。 1234567891011121314151617181920function shellSort(arr) &#123; var len = arr.length, temp, gap = 1; console.time('希尔排序耗时:'); while (gap &lt; len / 5) &#123; //动态定义间隔序列 gap = gap * 5 + 1; &#125; for (gap; gap &gt; 0; gap = Math.floor(gap / 5)) &#123; for (var i = gap; i &lt; len; i++) &#123; temp = arr[i]; for (var j = i - gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= gap) &#123; arr[j + gap] = arr[j]; &#125; arr[j + gap] = temp; &#125; &#125; console.timeEnd('希尔排序耗时:'); return arr;&#125; 归并排序 T(n) = O(nlogn) 123456789101112131415161718192021222324252627function mergeSort(arr) &#123; //采用自上而下的递归方法 var len = arr.length; if (len &lt; 2) &#123; return arr; &#125; var middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right));&#125;function merge(left, right) &#123; var result = []; console.time('归并排序耗时'); while (left.length &amp;&amp; right.length) &#123; if (left[0] &lt;= right[0]) &#123; result.push(left.shift()); &#125; else &#123; result.push(right.shift()); &#125; &#125; while (left.length) result.push(left.shift()); while (right.length) result.push(right.shift()); console.timeEnd('归并排序耗时'); return result;&#125; 快速排序 T(n) = O(nlogn)在数据集之中，选择一个元素作为”基准”（pivot）。 所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。 对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。 123456789101112131415function quickSort(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; var left = []; var right = []; for (var i = 0; i &lt; arr.length; i++)&#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat([pivot], quickSort(right));&#125;; 堆排序 O(nlogn) 堆是一个完全二叉树。 完全二叉树： 二叉树除开最后一层，其他层结点数都达到最大，最后一层的所有结点都集中在左边（左边结点排列满的情况下，右边才能缺失结点）。 大顶堆：根结点为最大值，每个结点的值大于或等于其孩子结点的值。 小顶堆：根结点为最小值，每个结点的值小于或等于其孩子结点的值。 将初始二叉树转化为大顶堆（heapify）（实质是从第一个非叶子结点开始，从下至上，从右至左，对每一个非叶子结点做shiftDown操作），此时根结点为最大值，将其与最后一个结点交换。 除开最后一个结点，将其余节点组成的新堆转化为大顶堆（实质上是对根节点做shiftDown操作），此时根结点为次最大值，将其与最后一个结点交换。 重复步骤2，直到堆中元素个数为1（或其对应数组的长度为1），排序完成。 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 交换两个节点function swap(A, i, j) &#123; let temp = A[i]; A[i] = A[j]; A[j] = temp; &#125;// 将 i 结点以下的堆整理为大顶堆，注意这一步实现的基础实际上是：// 假设 结点 i 以下的子堆已经是一个大顶堆，shiftDown函数实现的// 功能是实际上是：找到 结点 i 在包括结点 i 的堆中的正确位置。后面// 将写一个 for 循环，从第一个非叶子结点开始，对每一个非叶子结点// 都执行 shiftDown操作，所以就满足了结点 i 以下的子堆已经是一大//顶堆function shiftDown(A, i, length) &#123; let temp = A[i]; // 当前父节点// j&lt;length 的目的是对结点 i 以下的结点全部做顺序调整 for(let j = 2*i+1; j&lt;length; j = 2*j+1) &#123; temp = A[i]; // 将 A[i] 取出，整个过程相当于找到 A[i] 应处于的位置 if(j+1 &lt; length &amp;&amp; A[j] &lt; A[j+1]) &#123; j++; // 找到两个孩子中较大的一个，再与父节点比较 &#125; if(temp &lt; A[j]) &#123; swap(A, i, j) // 如果父节点小于子节点:交换；否则跳出 i = j; // 交换后，temp 的下标变为 j &#125; else &#123; break; &#125; &#125;&#125;// 堆排序function heapSort(A) &#123; // 初始化大顶堆，从第一个非叶子结点开始 for(let i = Math.floor(A.length/2-1); i&gt;=0; i--) &#123; shiftDown(A, i, A.length); &#125; // 排序，每一次for循环找出一个当前最大值，数组长度减一 for(let i = Math.floor(A.length-1); i&gt;0; i--) &#123; swap(A, 0, i); // 根节点与最后一个节点交换 shiftDown(A, 0, i); // 从根节点开始调整，并且最后一个结点已经为当 // 前最大值，不需要再参与比较，所以第三个参数 // 为 i，即比较到最后一个结点前一个即可 &#125;&#125; 计数排序 O(n+k)计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。 12345678910111213141516function countSort(ary) &#123; let newAry = new Array(ary.length).fill(0); for (const value of ary) &#123; newAry[value]++; &#125; ary = []; // 给ary重新赋值 for(var i =0; i&lt;newAry.length; i++) &#123; // 循环数字次数 for(var k = newAry[i]; k&gt;0; k--) &#123; ary.push(i); &#125; &#125; newAry = null; return ary; &#125; 桶排序 计算并设置固定数量的空桶 将数据放入对应的桶中 对桶中的数据进行排序 把每个桶的数据进行合并 已知需要排序的元素集合为 [ 29, 25, 3, 49, 9, 37, 21, 43] , 桶的数量K设置为5, 每个桶的区间跨度S设置为10 123456789101112131415161718192021222324252627282930function insertion_sort(A)&#123; for(let i=1; i&lt;A.length; i++)&#123; let p = i-1 const x = A[i] while(p&gt;=0 &amp;&amp; A[p]&gt;x)&#123; A[p+1] = A[p] p-- &#125; A[p+1] = x &#125;&#125;//桶排序function bucket_sort(A, k, s)&#123; //A排序数组,k桶子数量,s桶子空间尺度 const buckets = Array.from(&#123;length:k&#125;, ()=&gt;[]) //创建桶子 //把元素放入对应桶子 for(let i=0; i&lt;A.length; i++)&#123; //计算需要放入桶子序号 const idx = ~~(A[i]/s) buckets[idx].push(A[i]) &#125; //对每个桶子进行排序 for(let i=0; i&lt;buckets.length; i++)&#123; //此处选取插入排序, 空间消耗少,元素少常数时间消耗短 insertion_sort(buckets[i]) &#125; //把每个桶子数据合并 return [].concat(...buckets)&#125; 基数排序 取得数组中的最大值以及位数 arr为原始数组，从最低位开始取每个位组成radix数组 对radix进行计数排序（利用计数排序适用于小范围数的特点） 1234567891011121314151617181920212223242526272829303132333435function RadixLSDSort (arr, digit) &#123; const radix = 10; // 基数,以10进制来进行排序 var i = 0, j = 0, count = Array(radix), // 0~9的桶 len = arr.length, bucket = Array(len); // 利用LSD,也就是次位优先 for (var d = 0; d &lt; digit; d++) &#123; for (i = 0; i &lt; radix; i++) &#123; count[i] = 0; &#125; // 向各个桶中添加元素,并统计出每个桶中装的个数 for (i = 0; i &lt; len; i++) &#123; j = getDigit(arr[i], d); count[j]++; &#125; // count的越往后值最大,最大值为arr.length // count数组的值为,该位数值为该索引的数字总数 for (i = 1; i &lt; radix; i++) &#123; count[i] = count[i] + count[i - 1]; &#125; // 按照桶的顺序将导入temp中 for (i = len - 1; i &gt;= 0; i--) &#123; j = getDigit(arr[i], d); bucket[count[j] - 1] = arr[i]; count[j]--; &#125; // 将已经根据相应位数排好的序列导回arr中 for (i = 0; i &lt; len; i++) &#123; arr[i] = bucket[i]; &#125; &#125; return arr&#125; 算法对比","categories":[],"tags":[]},{"title":"width新特性","slug":"width新特性","date":"2020-05-26T08:35:59.223Z","updated":"2020-05-26T08:35:59.227Z","comments":true,"path":"2020/05/26/width新特性/","link":"","permalink":"http://wangjunxin.github.io/2020/05/26/width%E6%96%B0%E7%89%B9%E6%80%A7/","excerpt":"","text":"width新属性Created By: junxin wangLast Edited: May 10, 2020 3:07 PM width:fill-availablefill-availabel自动填充满剩余空间，价值在于使inline-block元素能100%自动填充 1div &#123; display:inline-block; width:fill-available; &#125; 此时的元素同时具备块状元素的自动填充特性以及内联元素的定位对齐特性，可以使用line-height让块状元素垂直居中 width：max-content假设我们的容器有足够的宽度，足够的空间，此时，所占据的宽度是就是max-content所表示的尺寸。 width:min-content宽度表示的并不是内部那个宽度小就是那个宽度，而是，采用内部元素最小宽度值最大的那个元素的宽度作为最终容器的宽度。 最小宽度值：替换元素，例如图片的最小宽度值就是图片呈现的宽度，对于文本元素，如果全部是中文，则最小宽度值就是一个中文的宽度值；如果包含英文，因为默认英文单词不换行，所以，最小宽度可能就是里面最长的英文单词的宽度。 width:fit-content实现元素收缩效果的同时，保持原本的block水平状态，于是，就可以直接使用margin:auto实现元素向内自适应同时的居中效果了 1234567891011121314151617.box &#123; background-color: #f0f3f9; padding: 10px; /* 这里左右方向是auto */ margin: 10px auto 20px; overflow: hidden;&#125;.fit-content &#123; width: -webkit-fit-content; width: -moz-fit-content; width: fit-content; &#125;&lt;div class=\"box fit-content\"&gt; &lt;img src=\"mm1.jpg\"&gt; &lt;p&gt;display:inline-block居中要靠父元素，而width:fit-content直接margin:auto.&lt;/p&gt;&lt;/div&gt;","categories":[],"tags":[]},{"title":"Vue-Cli本地https调试","slug":"Vue-Cli本地https调试","date":"2019-11-05T09:38:28.000Z","updated":"2019-11-05T10:15:01.046Z","comments":true,"path":"2019/11/05/Vue-Cli本地https调试/","link":"","permalink":"http://wangjunxin.github.io/2019/11/05/Vue-Cli%E6%9C%AC%E5%9C%B0https%E8%B0%83%E8%AF%95/","excerpt":"","text":"​ 这几天在做H5的语音录制，但是getUserMedia必须在https环境下运行，本地调试使用http://localhost:port/ 无法正常运行，需要配置本地https环境。 ​ 网上通常使用生成本地证书的方案： 生成根SSL证书 信任根SSL证书 在node的Express服务中读取生成的证书 12345678910111213var path = require('path')var fs = require('fs')var express = require('express')var https = require('https')var certOptions = &#123; key: fs.readFileSync(path.resolve('build/cert/server.key')), cert: fs.readFileSync(path.resolve('build/cert/server.crt'))&#125;var app = express()var server = https.createServer(certOptions, app).listen(443) 后来查看vue-cli文档的时候偶然发现vue-cli-service有一个–https选项 通过命令：vue-cli-service serve –https启动项目发现启动的时候修改为https启动 配置参数：","categories":[],"tags":[]},{"title":"数组去重","slug":"数组去重","date":"2019-11-04T10:08:07.000Z","updated":"2020-06-15T09:33:58.833Z","comments":true,"path":"2019/11/04/数组去重/","link":"","permalink":"http://wangjunxin.github.io/2019/11/04/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/","excerpt":"","text":"数组去重Created By: junxin wangLast Edited: May 18, 2020 2:02 PM 简单数字数组去重123456789function unique(list) &#123; let result = [] list.forEach(item =&gt; &#123; if (result.indexOf(item) &lt; 0) &#123; result.push(item) &#125; &#125;) return result&#125; es6 123function unique(list) &#123; return Array.from(new Set(list))&#125; google写法(对象比较只针对同一引用，同时对象中加入了新属性) 1234567891011121314151617181920212223242526272829303132333435goog.array.removeDuplicates = function(arr, opt_rv, opt_hashFn) &#123; var returnArray = opt_rv || arr; var defaultHashFn = function(item) &#123; // Prefix each type with a single character representing the type to // prevent conflicting keys (e.g. true and 'true'). return goog.isObject(item) ? 'o' + goog.getUid(item) : (typeof item).charAt(0) + item; &#125;; var hashFn = opt_hashFn || defaultHashFn; var seen = &#123;&#125;, cursorInsert = 0, cursorRead = 0; while (cursorRead &lt; arr.length) &#123; var current = arr[cursorRead++]; var key = hashFn(current); if (!Object.prototype.hasOwnProperty.call(seen, key)) &#123; seen[key] = true; returnArray[cursorInsert++] = current; &#125; &#125; returnArray.length = cursorInsert;&#125;;goog.getUid = function(obj) &#123; // TODO(arv): Make the type stricter, do not accept null. return Object.prototype.hasOwnProperty.call(obj, goog.UID_PROPERTY_) &amp;&amp; obj[goog.UID_PROPERTY_] || (obj[goog.UID_PROPERTY_] = ++goog.uidCounter_);&#125;;goog.isObject = function(val) &#123; var type = typeof val; return type == 'object' &amp;&amp; val != null || type == 'function'; // return Object(val) === val also works, but is slower, especially if val is // not an object.&#125;;goog.UID_PROPERTY_ = 'closure_uid_' + ((Math.random() * 1e9) &gt;&gt;&gt; 0);goog.uidCounter_ = 0; 对象对比12345678910111213141516function compare(obj1,obj2)&#123; if(Object.keys(obj1).length != Object.keys(obj2).length)&#123; return false &#125;else&#123; for(key in obj1)&#123; if(obj2.hasOwnProperty(key))&#123; if( !Object.is(obj1[key],obj2[key]))&#123; return false; &#125; &#125;else&#123; return false &#125; &#125; return true &#125;&#125;","categories":[],"tags":[]}]}